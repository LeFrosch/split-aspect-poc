load("//common:common.bzl", "intellij_common")
load("//common:dependencies.bzl", "intellij_deps")
load("//common:ide_info.bzl", "ide_info")
load("//modules:provider.bzl", "intellij_provider")
load(":provider.bzl", "IntelliJInfo", "intellij_info_builder")

# compile time dependencies collected for every target
COMPILE_TIME_DEPS = ["deps"]

def _merge_dependencies(builder, ctx):
    """Adds information from all dependencies' intellij info providers."""
    for name in dir(ctx.rule.attr):
        for dep in intellij_common.attr_as_label_list(ctx, name):
            if not IntelliJInfo in dep:
                continue

            intellij_info_builder.append(builder, dep[IntelliJInfo])

def _serialize_dependencies(builder):
    """Serializes all dependencies currently tracked by the builder."""
    return [
        struct(target = dep[intellij_common.TargetInfo].key, dependency_type = key)
        for key, list_of_sets in builder.dependencies.items()
        for set in list_of_sets
        for dep in set.to_list()
        if intellij_common.TargetInfo in dep
    ]

def _collect_toolchain_info(target):
    return [
        target[provider]
        for provider in intellij_provider.TOOLCHAINS
        if provider in target and target[provider].present
    ]

def _merge_target_info(builder, target, ctx):
    """Adds information collected from the current target's module providers."""

    # for backwards compatability with Bazel 8 and below, toolchains are dependencies
    intellij_info_builder.append_ide_infos(builder, [it.info_file for it in _collect_toolchain_info(target)])

    # do not generate a intellij-info.txt if there is no lanaguge module attachted
    if not intellij_provider.has_module(target):
        return {}

    if "no-ide" in ctx.rule.attr.tags:
        return []

    info = {}

    # iterate over all providers that could be generated by a module aspect
    for name, module_provider in intellij_provider.MODULE_MAP.items():
        if not module_provider in target or not target[module_provider].present:
            continue

        provider = target[module_provider]

        # update the data persisted to the output file
        info[name] = provider.value

        # merge all information provided by the module provider into the main provider
        intellij_info_builder.append(builder, provider)

        toolchain_infos = [
            info
            for toolchain_target in provider.toolchains
            for info in _collect_toolchain_info(toolchain_target)
        ]

        # add toolchains as dependencies to the current target
        intellij_info_builder.append_dependencies(
            builder,
            intellij_deps.TOOLCHAIN,
            depset([it.owner for it in toolchain_infos]),
        )

        # append the already generated info from the toolchains
        intellij_info_builder.append_ide_infos(builder, [it.info_file for it in toolchain_infos])

    # dependencies have to be serialized last because they might be updated by module providers
    info["deps"] = _serialize_dependencies(builder)

    # write the ide info to file and add the generated file to the appropriate output group
    intellij_info_builder.append_ide_infos(builder, [ide_info.write(target, ctx, info)])

def _aspect_impl(target, ctx):
    builder = intellij_info_builder.create()

    intellij_info_builder.append_dependencies(
        builder,
        intellij_deps.COMPILE_TIME,
        intellij_deps.collect(ctx, COMPILE_TIME_DEPS),
    )

    _merge_target_info(builder, target, ctx)
    _merge_dependencies(builder, ctx)

    intellij_info = intellij_info_builder.build(builder)

    return [intellij_info, OutputGroupInfo(**intellij_info.outputs)]

intellij_info_aspect = intellij_common.aspect(
    implementation = _aspect_impl,
    required_aspect_providers = [[it] for it in intellij_provider.ALL],
    provides = [IntelliJInfo],
)
