load("//common:artifact_location.bzl", "artifact_location")
load("//common:common.bzl", "intellij_common")
load("//common:dependencies.bzl", "intellij_deps")
load("//modules:provider.bzl", "intellij_provider")
load(":provider.bzl", "IntelliJInfo", "intellij_info")

# compile time dependencies collected for every target
COMPILE_TIME_DEPS = ["deps"]

def _get_build_file_location(ctx):
    """Creates an ArtifactLocation proto representing a location of a given BUILD file."""
    return artifact_location.create(
        ctx.label.workspace_root,
        ctx.label.package + "/BUILD",
        True,
        intellij_common.label_is_external(ctx.label),
    )

def _merge_dependencies(provider, ctx):
    """Adds information from all dependencies' intellij info providers."""
    for name in dir(ctx.rule.attr):
        for dep in intellij_common.attr_as_label_list(ctx, name):
            if not IntelliJInfo in dep:
                continue

            intellij_info.update(provider, dep[IntelliJInfo])

def _serialize_dependencies(provider):
    return [
        struct(target = dep[intellij_common.TargetInfo].key, dependency_type = key)
        for key, deps in provider.dependencies.items()
        for dep in deps.to_list()
        if intellij_common.TargetInfo in dep
    ]

def _write_ide_info(target, ctx, info):
    """Serializes and writes the info struct to the intellij-info.txt file."""

    # bazel allows target names differing only by case, so append a hash to support case-insensitive file systems
    file_name = "%s-%s.intellij-info.txt" % (target.label.name, intellij_common.target_hash(target))

    file = ctx.actions.declare_file(file_name)
    ctx.actions.write(file, proto.encode_text(struct(**info)))

    return file

def _merge_target_info(provider, target, ctx):
    """Adds information collected from the current target's module providers."""
    if not intellij_provider.any(target):
        return {}

    tags = ctx.rule.attr.tags

    if "no-ide" in tags:
        return []

    ide_info = {
        "build_file_artifact_location": _get_build_file_location(ctx),
        "kind_string": ctx.rule.kind,
        "tags": tags,
        "key": target[intellij_common.TargetInfo].key,
    }

    # iterate over all providers that could be generated by a module aspect
    for name, module_provider in intellij_provider.ALL.items():
        if not module_provider in target or not target[module_provider].present:
            continue

        # update the data persisted to the output file
        ide_info[name] = target[module_provider].value

        # merge all information provided by the module provider into the main provider
        intellij_info.update(provider, target[module_provider])

    # dependencies have to be serialized last because they might be updated by module providers
    ide_info["deps"] = _serialize_dependencies(provider)

    # write the ide info to file and add the generated file to the appropriate output group
    intellij_info.add_ide_info(provider, _write_ide_info(target, ctx, ide_info))

def _aspect_impl(target, ctx):
    provider = intellij_info.create()

    intellij_info.add_deps(
        provider,
        intellij_deps.COMPILE_TIME,
        intellij_deps.collect(ctx, COMPILE_TIME_DEPS),
    )

    _merge_target_info(provider, target, ctx)
    _merge_dependencies(provider, ctx)

    return [provider, OutputGroupInfo(**provider.outputs)]

intellij_info_aspect = intellij_common.aspect(
    implementation = _aspect_impl,
    required_aspect_providers = [[it] for it in intellij_provider.ALL.values()],
    provides = [IntelliJInfo],
)
